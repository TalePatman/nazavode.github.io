+++
categories = ["Lectures", "C"]
date = "2017-03-11T00:13:08+01:00"
description = ""
tags = [""]
title = "Aliasing in C explained"
draft = true
+++

Since my job involves mainly HPC stuff and *performance-obsessed code*, one of
the first topics I had to dive into was **aliasing in the C standard**. This
article ties to summarize all I learned while diving into this potentially
sneaky topic.

So what is an *alias*? Let's try to clarify this a bit:

> One pointer (*lvalue expression*) is said to **alias** another pointer when
> both refer to the **same location or object**

In practice, an *alias* involves referring to the same phisical entity (an
object stored in memory) through multiple handlers (*pointers*):

```c
int i;
int *ptr1 = &i;
int *ptr2 = &i;
```

In this trivial example, `ptr1` and `ptr2` are both aliases of each other since
they are pointing to the same object (the integer `i`).

Just a quick note: even if we are talking about *pointers* and C-ish stuff,
this concept is valid for *all* programming languages: a lot of recent languages
use pointers (Go, for example) but in C this isssue is a lot more critical since
we can do *arithmetics* with them, moving pointers around in memory as we like.


## Why should I care?

Got it, this is *the* question. Why should I care about aliasing at all?

The short answer is: if you are writing code that isn't supposed to be pushed to
its limits in terms of performance, *you can ignore aliasing at all and be happy*.

Let's start with a trivial example:

{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "c-example-01.c">}}

Even an harmless snippet like this can raise a nasty issue when feed to the compiler.
Let's dive into the `x86` assymbly code generated by `$ gcc -std=c11 -O2 -fno-strict-aliasing`:

{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "c-example-01-nostrictaliasing.s">}}

Why are we loading the same data twice? Performing a load twice per iteration
means halving our memory bandwidth (probably the cache here comes to help) and
wasting a lot of clock cycles.

How can we help the compiler in doing a better job?

## Aliasing rules

In the [ISO C standard document][iso-doc], it is precisely stated how we can access an
object or, in other words, *what is the type of the pointer that can legally refer
to an object*:

> An object shall have its stored value **accessed only by an lvalue expression**
> that has one of the **following types**:
> 
> * a **type compatible** with the effective type of the object,
> * a **qualified version** of a **type compatible** with the effective type of
>   the object,
> * a type that is the **signed or unsigned** type corresponding to the effective
>   type of the object,
> * a type that is the signed or unsigned type corresponding to a qualified version
>   of the effective type of the object,
> * an **aggregate or union** type that includes one of the aforementioned types
>   among its members (including, recursively, a member of a subaggregate or 
>   contained union), or
> * a **character** type.
>
> *(ISO/IEC 9899:201x, Section 6.5)*


Just a note about terminology: in the ISO C world, **strict aliasing**, **ANSI
aliasing** and **type-based aliasing** are exactly the same thing, they **refer
all to the same concept** (actually they are *aliases*, sorry for the pun :).


## Let's exploit the standard


`$ gcc -std=c11 -O2 -fstrict-aliasing`

{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "c-example-01-strictaliasing.s">}}

The compiler trusts our words blindly.


## Compatible types

Let's take our function and modify the type of one of the pointer parameters:

{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "c-example-02.c">}}

`gcc -std=c11 -O2 -fstrict-aliasing`

{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "c-example-02-strictaliasing.s">}}

Even if we ask the compiler to exploit the standard aliasing rules, the use of
*compatible types* leads to the come back of the extra instruction. What we are
seeing here is that for the standard rules, both `fltArrIn` and `fltArrOut` are
pointers of type `float` (compatible by definition since it's exactly the same
type) so the compiler must assume that they can be *aliases* to each other
referring to the same object in memory. How can we escape this ditch?

## The `restrict` qualifier

Diamo al compilatore qualche sicurezza in più (sotto la nostra totale responsabilità):

{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "c-example-03.c">}}

`$ gcc -std=c11 -O2 -fstrict-aliasing -restrict`

{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "c-example-03-strictaliasing.s">}}

Attivando le regole dello standard, il compilatore si fida ciecamente della nostra parola.

Qualificatore introdotto nello standard C99 (anche se presente in tutti i compilatori come estensione).
Ha senso solo se qualifica puntatori.

> An object that is accessed through a `restrict`-qualified pointer has a 
> **special association** with that pointer. This association [...] requires
> that **all accesses to that object use, directly or indirectly, the value of
> that particular pointer**.
>
> *ISO/IEC 9899:201x, Section 6.7.3*

> For example, a statement that assigns a value returned by `malloc` to a single
> pointer establishes this association between the allocated object and the pointer.
>
> *ISO/IEC 9899:201x, Section 6.7.3*

> The intended use of the `restrict` qualifier [...] is to **promote optimization**,
> and **deleting all instances of the qualifier** from all preprocessing translation
> units composing a conforming program **does not change its meaning
> (i.e., observable behavior)**.
>
> *ISO/IEC 9899:201x, Section 6.7.3*

all’interno dello stesso blocco.
  Se in blocchi diversi (nested), è possibile il caching del puntatore ma vengono imposti altri vincoli (outer-to-inner rule)!

N.B.: le regole imposte da restrict non fanno alcuna differenza fra chiamata di funzione e nested block.

Esempio 1: p e q restricted
{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "c-example-04.c">}}

Esempio 2: chiamata di f
{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "c-example-05.c">}}

Esempio 3: restrict + read only = OK
{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "c-example-06.c">}}

Esempio 4: outer-to-inner rule
{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "c-example-07.c">}}

## A more complex example

{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "example-move-01.c">}}

`gcc -std=c11 –O3 -fstrict-aliasing` (3.4.1 for PowerPC)

{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "example-move-01.s">}}

### Memory windows tracking

Let's modify our function adding some unit-scoped arrays:

{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "example-move-02.c">}}

`gcc -std=c11 –O3 -fstrict-aliasing` (3.4.1 for PowerPC)

{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "example-move-02.s">}}


Memory windows (stripes/data channels):

```
    velocity[0] ---> [1] ---> [2] ---> [N]
    position[0] ---> [1] ---> [2] ---> [N]
acceleration[0] ---> [1] ---> [2] ---> [N]
```

Let's modify our function adding some restricts:

{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "example-move-03.c">}}

`gcc -std=c11 –O3 -fstrict-aliasing` (3.4.1 for PowerPC)

{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "example-move-03.s">}}

### Overlapped memory windows

Prova 

{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "example-overlapped.c">}}

Are we breaking the rules here?

Il restrict non dice che l’oggetto puntato è completamente privo di alias, solo che gli indirizzi letti (load) e scritti (store) lo sono.

Non importa che le memory windows siano sovrapposte, l’importante è che gli accessi siano disgiunti (Regola delle Piastrelle©).

## Pointers hierarchy

E’ possibile copiare localmente (outer-to-inner) ed utilizzare il valore dei puntatori restrict: si crea (implictamente) una gerachia di puntatori.

E’ possibile accedere agli oggetti puntati solamente attraverso le foglie della gerarchia. Ogni accesso da un livello più alto è una violazione ed il risultato è indefinito.

{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "example-memorywindows.c">}}

Hierarchy:

```
                |---> velocity_x
velocity -------|---> velocity_y
                |---> velocity_z

                |---> position_x
position -------|---> position_y
                |---> position_z

                |---> acceleration_x
acceleration ---|---> acceleration_y
                |---> acceleration_z
```

## What happens in other languages

Since we are talking about *references* and *objects in memory*, aliasing is a
concept shared by all programming languages. In the modern ones, this issue is
ignored (preventing any optimization, obviously) or just carefully handled by
the language definition itself. But what happens in some *classic* languages?

### Aliasing in `C++`

Per il C++, le regole di aliasing del C99 sono estese dai tipi compatibili ai tipi dinamici compatibili.

Aliasing between dynamic types:

{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "example-dynamic.cpp">}}

In caso di tipi di uso generico, il C++ si avvale della template metaprogramming: per il compilatore due istanze di uno stesso tipo template sono due tipi completamente scorrelati.

{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "example-static.cpp">}}

### Aliasing in `FORTRAN`

People doing numerical stuff do love `FORTRAN`, and for good reasons: it is
carefully cut for their needs, designed from the ground up for numerical codes.
And people doing numerical stuff do love saying that `FORTRAN` is faster than
any othe language they ever tried (or just read about, usually they think is
enough). Well, this is obviously not true, especially when comparing `FORTRAN`
and `C`. There is a caveat though: if you don't know the `C` language, during
casual use it's likely that compiled `FORTRAN` will produce faster assembly
code. Ther is a reason of course: regarding aliasing, the designers took the
easy way **forbidding it at all**. **Aliasing in `FORTRAN` is strictly
forbidden**, except for read-only references.

So, a function like the following:

{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "fortran-example-01.f95">}}

...cannot be called in this way:

{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "fortran-example-02.f95">}}

The fact that we are passing the *same* reference to both the parameters yields
an **undefined behaviour** with its load of potentially mind crushing bugs.

## What to take away from here

* Always switch on all the warnings your compiler can detect for you, you're
  gonna get some false positives but they are far better than some devilish
  aliasing bug;
* look into the assembly code generated for your hotspots, that is the best and
  quickest way to be sure whether the compiler is doing a god job or not with
  our `restrict` qualifiers and aliasing control flags;
* don't break the *outer-to-inner* rule, that would open the gates of hell;
* remember that *memory windows* can overlap;
* publish at the higher possible level (right in the public API) your assumptions about
  aliasing. If some API parameters must be `restrict`, go for it and highlight
  it in the documentation;
* if you need it, start using the `restrict` qualifier as soon as possible
  during the development. Adding it on an already completed code would need to
  deeply understand its memory access patterns;

The most important thing I've learned is: when writing high performance and
number crunching codes in C (and formal languages in general), **never, ever
blame the compiler if your code turns out to be deadly slow**.


----------

Resources:

* [ISO/IEC 9899:201x][iso-doc]

[iso-doc]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf
