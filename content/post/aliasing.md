+++
categories = ["Lectures", "C"]
date = "2017-03-11T00:13:08+01:00"
description = ""
tags = [""]
title = "Aliasing in C explained"
draft = true
+++

Since my job involves mainly HPC stuff and *performance-obsessed code*, one of
the first topics I had to dive into was **aliasing in the C standard**. This
article ties to summarize all I learned while diving into this potentially
sneaky topic.

So what is an *alias*? Let's try to clarify this a bit:

> One pointer (*lvalue expression*) is said to **alias** another pointer when
> both refer to the **same location or object**

In practice, an *alias* involves referring to the same phisical entity (an
object stored in memory) through multiple handlers (*pointers*):

```
int i;
int *ptr1 = &i;
int *ptr2 = &i;
```

In this trivial example, `ptr1` and `ptr2` are both aliases of each other since
they are pointing to the same object (the integer `i`).

Just a quick note: even if we are talking about *pointers* and C-ish stuff,
this concept is valid for *all* programming languages: a lot of recent languages
use pointers (Go, for example) but in C this isssue is a lot more critical since
we can do *arithmetics* with them, moving pointers around in memory as we like.


## Why should I care?

Got it, this is *the* question. Why should I care about aliasing at all?

The short answer is: if you are writing code that isn't supposed to be pushed to
its limits in terms of performance, *you can ignore aliasing at all and be happy*.

Let's start with a trivial example:

```
void foo (float *out_vector_a, float *out_vector_b, int *in_vector, int n)
{
    for(int i=0; i<n; ++i) {
        out_vector_a[i] = in_vector[i];
        out_vector_b[i] = in_vector[i];
    }
}
```

Even an harmless snippet like this can raise a nasty issue when feed to the compiler.
Let's dive into the Intel assembly code generated by `gcc` (disassembled through
`objdump`):


{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "example_func_01.s">}}


{{< highlight objdump-nasm "hl_lines=3 7" >}}
      out_vector_a[i] = in_vector[i];
  10:	66 0f ef c0          	pxor   xmm0,xmm0
  14:	f3 0f 2a 04 82       	cvtsi2ss xmm0,DWORD PTR [rdx+rax*4]
  19:	f3 0f 11 04 87       	movss  DWORD PTR [rdi+rax*4],xmm0
      out_vector_b[i] = in_vector[i];
  1e:	66 0f ef c0          	pxor   xmm0,xmm0
  22:	f3 0f 2a 04 82       	cvtsi2ss xmm0,DWORD PTR [rdx+rax*4]
  27:	f3 0f 11 04 86       	movss  DWORD PTR [rsi+rax*4],xmm0
{{< / highlight >}}

{{< highlight bash "hl_lines=3 7" >}}
      out_vector_a[i] = in_vector[i];
  10:	cleanup vector register xmm0
  14:	cast int -> float and load memory location in_vector[i] into xmm0
  19:	store xmm0 into memory location out_vector_a[i]
      out_vector_b[i] = in_vector[i];
  1e:	cleanup vector register xmm0
  22:	cast int -> float and load memory location in_vector[i] into xmm0
  27:	store xmm0 into memory location out_vector_b[i]
{{< / highlight >}}

There are no doubts about the first three instructions, we are spending cycles
to carry out useful work. But what about the fourth instruction? That is
actually a load instruction that tells the CPU to load the content of the same
memory location as the previous one (`[rdx+rax*4]`) in a different vector
register (`%xmm1`). Why are we loading the same data twice? That is because in
the previous instruction (`movss`) the CPU wrote in a location inside the
boundaries of array `fltArrOut` and **in order to guarantee semantic
correctness, the compiler assumes that the previous instruction could have wrote
in the same area, in other words that `fltArrIn` could be an alias for
`fltArrOut`** and to avoid issues loads the same data from memory again, if the
location has been written during the previous instruction its updated content
is correctly retrieved in its updated state.

Of course, performing a load twice means halving our memory bandwidth so we are
actually wasting a lot of clock cycles. How can we help the compiler in doing a
better job?

## Aliasing rules

In the [ISO C standard document][iso-doc] the committee precisely stated how we can access an
object or, in other words, *what is the type of the pointer that can legally refer
to an object*:

> An object shall have its stored value **accessed only by an lvalue expression**
> that has one of the **following types**:
>
> * a **type compatible** with the effective type of the object,
> * a **qualified version** of a **type compatible** with the effective type of
>   the object,
> * a type that is the **signed or unsigned** type corresponding to the effective
>   type of the object,
> * a type that is the signed or unsigned type corresponding to a qualified version
>   of the effective type of the object,
> * an **aggregate or union** type that includes one of the aforementioned types
>   among its members (including, recursively, a member of a subaggregate or
>   contained union), or
> * a **character** type.
>
> *(ISO/IEC 9899:201x, Section 6.5)*

Don't worry about the definition of *compatible types*, it is exactly what you
are thinking (except for `struct`, but we can ignore that):

> Two types have *compatible type* if their types are the same.
>
> *(ISO/IEC 9899:201x, Section 6.2.7)*

So, following the rules, we can have pointers that are aliases in a lot of
different legal ways. These *could be* valid aliases of each other:

```
int *a;
char *b;

typedef union {
    char c;
    float f;
} Mask;

Mask *d;
```

...but these couldn't:

```
long *a;
double *b;
```

Note that a `char *` **is always a potential alias** since `char` is the minimum
allocation unit in C, all type sizes are specified in `char` units and `char`
pointers are the way to swipe raw memory (for copying chunks regardless of the
underlying object type, for example).

Just a note about terminology: in the ISO C world, **strict aliasing**, **ANSI
aliasing** and **type-based aliasing** are exactly the same thing, they all **refer
to the same concept** (actually they are *aliases*...sorry for the pun :).

## Let's exploit the law

So, what about our previous example? We were dealing with two pointers of incompatible
types (`int *` and `float *`), so `fltArrOut` and `intArrIn` aren't legal aliases.
Anyway the compiler treated them as they were, that is because it works in a
conservative way and assumes that the programmer doesn't care about aliasing
rules and it tries to not to insert *very* subtle bugs. Let's try to tell `gcc`
to blindly follow the standard with the proper flag `-fstrict-aliasing`. This
time I've left out the full assembly file (you can find it
[here](https://gist.githubusercontent.com/nazavode/22326361646ba3cfd24cec3fd9594d49/raw/a65080776ef619009a0dff9374d593661eb63563/example_func_02.s)),
let's have a look to the interesting lines instead, the same lines that we were
looking at before:

{{< highlight objdump-nasm "hl_lines=3" >}}
        out_vector_a[i] = in_vector[i];
    10:	66 0f ef c0          	pxor   xmm0,xmm0
    14:	f3 0f 2a 04 82       	cvtsi2ss xmm0,DWORD PTR [rdx+rax*4]
    19:	f3 0f 11 04 87       	movss  DWORD PTR [rdi+rax*4],xmm0
        out_vector_b[i] = in_vector[i];
    1e:	f3 0f 11 04 86       	movss  DWORD PTR [rsi+rax*4],xmm0
    23:	48 83 c0 01          	add    rax,0x1
{{< / highlight >}}

This time **the second load disappeared**.

{{< highlight bash "hl_lines=3" >}}
      out_vector_a[i] = in_vector[i];
  10:	cleanup vector register xmm0
  14:	cast int -> float and load memory location in_vector[i] into xmm0
  19:	store xmm0 into memory location out_vector_a[i]
      out_vector_b[i] = in_vector[i];
  1e:	store xmm0 into memory location out_vector_b[i]
{{< / highlight >}}

Let's take our function and modify the type of one of the pointer parameters:

```
void foo (float *out_vector_a, float *out_vector_b, float *in_vector, int n)
{
    for(int i=0; i<n; ++i) {
        out_vector_a[i] = in_vector[i];
        out_vector_b[i] = in_vector[i];
    }
}
```

`gcc -std=c11 -O2 -fstrict-aliasing`

{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "c-example-02-strictaliasing.s">}}

Even if we ask the compiler to exploit the standard aliasing rules, the use of
*compatible types* leads to the come back of the extra instruction. What we are
seeing here is that for the standard rules, both `fltArrIn` and `fltArrOut` are
pointers of type `float` (compatible by definition since it's exactly the same
type) so the compiler must assume that they can be *aliases* to each other
referring to the same object in memory. How can we escape this ditch?

## The `restrict` qualifier

Luckily the standard provide us a tool to tell the compiler **under our responsibility**
that even two pointers could be legal aliases, we are actually guaranteeing that
they aren't:

{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "c-example-03.c">}}

Let's build this new version with a new flag:

`$ gcc -std=c11 -O2 -fstrict-aliasing -restrict`

{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "c-example-03-strictaliasing.s">}}

Attivando le regole dello standard, il compilatore si fida ciecamente della nostra parola.

Qualificatore introdotto nello standard C99 (anche se presente in tutti i compilatori come estensione).
Ha senso solo se qualifica puntatori.

> An object that is accessed through a `restrict`-qualified pointer has a
> **special association** with that pointer. This association [...] requires
> that **all accesses to that object use, directly or indirectly, the value of
> that particular pointer**.
>
> *ISO/IEC 9899:201x, Section 6.7.3*

> For example, a statement that assigns a value returned by `malloc` to a single
> pointer establishes this association between the allocated object and the pointer.
>
> *ISO/IEC 9899:201x, Section 6.7.3*

> The intended use of the `restrict` qualifier [...] is to **promote optimization**,
> and **deleting all instances of the qualifier** from all preprocessing translation
> units composing a conforming program **does not change its meaning
> (i.e., observable behavior)**.
>
> *ISO/IEC 9899:201x, Section 6.7.3*

all’interno dello stesso blocco.
  Se in blocchi diversi (nested), è possibile il caching del puntatore ma vengono imposti altri vincoli (outer-to-inner rule)!

N.B.: le regole imposte da restrict non fanno alcuna differenza fra chiamata di funzione e nested block.

Esempio 1: p e q restricted
{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "c-example-04.c">}}

Esempio 2: chiamata di f
{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "c-example-05.c">}}

Esempio 3: restrict + read only = OK
{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "c-example-06.c">}}

Esempio 4: outer-to-inner rule
{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "c-example-07.c">}}

## A more complex example

{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "example-move-01.c">}}

`gcc -std=c11 –O3 -fstrict-aliasing` (3.4.1 for PowerPC)

{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "example-move-01.s">}}

### Memory windows tracking

Let's modify our function adding some unit-scoped arrays:

{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "example-move-02.c">}}

`gcc -std=c11 –O3 -fstrict-aliasing` (3.4.1 for PowerPC)

{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "example-move-02.s">}}


Memory windows (stripes/data channels):

```
    velocity[0] ---> [1] ---> [2] ---> [N]
    position[0] ---> [1] ---> [2] ---> [N]
acceleration[0] ---> [1] ---> [2] ---> [N]
```

Let's modify our function adding some restricts:

{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "example-move-03.c">}}

`gcc -std=c11 –O3 -fstrict-aliasing` (3.4.1 for PowerPC)

{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "example-move-03.s">}}

### Overlapped memory windows

Prova

{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "example-overlapped.c">}}

Are we breaking the rules here?

Il restrict non dice che l’oggetto puntato è completamente privo di alias, solo che gli indirizzi letti (load) e scritti (store) lo sono.

Non importa che le memory windows siano sovrapposte, l’importante è che gli accessi siano disgiunti (Regola delle Piastrelle©).

## Pointers hierarchy

E’ possibile copiare localmente (outer-to-inner) ed utilizzare il valore dei puntatori restrict: si crea (implictamente) una gerachia di puntatori.

E’ possibile accedere agli oggetti puntati solamente attraverso le foglie della gerarchia. Ogni accesso da un livello più alto è una violazione ed il risultato è indefinito.

{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "example-memorywindows.c">}}

Hierarchy:

```
                |---> velocity_x
velocity -------|---> velocity_y
                |---> velocity_z

                |---> position_x
position -------|---> position_y
                |---> position_z

                |---> acceleration_x
acceleration ---|---> acceleration_y
                |---> acceleration_z
```

## What happens in other languages

Since we are talking about *references* and *objects in memory*, aliasing is a
concept shared by all programming languages. In the modern ones, this issue is
ignored (preventing any optimization, obviously) or just carefully handled by
the language definition itself. But what happens in some *classic* languages?

### Aliasing in `C++`

Per il C++, le regole di aliasing del C99 sono estese dai tipi compatibili ai tipi dinamici compatibili.

Aliasing between dynamic types:

{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "example-dynamic.cpp">}}

In caso di tipi di uso generico, il C++ si avvale della template metaprogramming: per il compilatore due istanze di uno stesso tipo template sono due tipi completamente scorrelati.

{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "example-static.cpp">}}

### Aliasing in `FORTRAN`

People doing numerical stuff do love `FORTRAN`, and for good reasons: it is
carefully cut for their needs, designed from the ground up for numerical codes.
And people doing numerical stuff do love saying that `FORTRAN` is faster than
any othe language they ever tried (or just read about, usually they think is
enough). Well, this is obviously not true, especially when comparing `FORTRAN`
and `C`. There is a caveat though: if you don't know the `C` language, during
casual use it's likely that compiled `FORTRAN` will produce faster assembly
code. Ther is a reason of course: regarding aliasing, the designers took the
easy way **forbidding it at all**. **Aliasing in `FORTRAN` is strictly
forbidden**, except for read-only references.

So, a function like the following:

{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "fortran-example-01.f95">}}

...cannot be called in this way:

{{<gist nazavode 22326361646ba3cfd24cec3fd9594d49 "fortran-example-02.f95">}}

The fact that we are passing the *same* reference to both the parameters yields
an **undefined behaviour** with its load of potentially mind crushing bugs.

## What to take away from here

* Always switch on all the warnings your compiler can detect for you, you're
  gonna get some false positives but they are far better than some devilish
  aliasing bug;
* look into the assembly code generated for your hotspots, that is the best and
  quickest way to be sure whether the compiler is doing a god job or not with
  our `restrict` qualifiers and aliasing control flags;
* don't break the *outer-to-inner* rule, that would open the gates of hell;
* remember that *memory windows* can overlap;
* publish at the higher possible level (right in the public API) your assumptions about
  aliasing. If some API parameters must be `restrict`, go for it and highlight
  it in the documentation;
* if you need it, start using the `restrict` qualifier as soon as possible
  during the development. Adding it on an already completed code would need to
  deeply understand its memory access patterns;

The most important thing I've learned is: when writing high performance and
number crunching codes in C (and formal languages in general), **never, ever
blame the compiler if your code turns out to be deadly slow**.


----------

Resources:

* [ISO/IEC 9899:201x][iso-doc]

[iso-doc]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf
